import React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { IconChevronDown, IconSparkles } from '@tabler/icons-react';

import { cn, type IconProp, renderIcon } from '../../lib/utils';
import { Button } from '../Button';
import { Tag } from '../Tag';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '../../lib/components/Popover';
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
} from '../../lib/components/Command';
import { Checkbox } from '../Checkbox';

/**
 * Animation types and configurations
 */
export interface AnimationConfig {
  /** Badge animation type */
  badgeAnimation?: 'bounce' | 'pulse' | 'fade' | 'slide' | 'none';
  /** Popover animation type */
  popoverAnimation?: 'scale' | 'slide' | 'fade' | 'flip' | 'none';
  /** Option hover animation type */
  optionHoverAnimation?: 'highlight' | 'scale' | 'glow' | 'none';
  /** Animation duration in seconds */
  duration?: number;
  /** Animation delay in seconds */
  delay?: number;
}

/**
 * Variants for the multi-select component to handle different styles.
 */
const multiSelectVariants = cva('ease-in-out transition-all duration-300', {
  variants: {
    variant: {
      default: `border-divider-default text-body-primary bg-surface-primary
      hover:bg-surface-secondary`,
      secondary: `border-divider-default bg-surface-secondary text-body-primary
      hover:bg-surface-tertiary`,
      destructive: `bg-interactive-alert-default text-interactive-inverse
      hover:bg-interactive-alert-hover border-transparent`,
    },
    badgeAnimation: {
      bounce: 'hover:-translate-y-1 hover:scale-110',
      pulse: 'hover:animate-pulse',
      fade: 'hover:opacity-80',
      slide: 'hover:translate-x-1',
      none: '',
    },
  },
  defaultVariants: {
    variant: 'default',
    badgeAnimation: 'none',
  },
});

/**
 * Option interface for MultiSelect component
 */
interface MultiSelectOption {
  /** The text to display for the option. */
  label: string;
  /** The unique value associated with the option. */
  value: string;
  /** Optional icon component to display alongside the option. */
  icon?: IconProp;
  /** Whether this option is disabled */
  disabled?: boolean;
  /** Custom styling for the option */
  style?: {
    /** Custom badge color */
    badgeColor?: string;
    /** Custom icon color */
    iconColor?: string;
    /** Gradient background for badge */
    gradient?: string;
  };
}

/**
 * Group interface for organizing options
 */
interface MultiSelectGroup {
  /** Group heading */
  heading: string;
  /** Options in this group */
  options: MultiSelectOption[];
}

/**
 * Render function context for rendering custom option content
 */
export interface RenderOptionContext {
  /** The option being rendered */
  option: MultiSelectOption;
  /** Whether this is rendering in the dropdown list or as a selected badge */
  location: 'dropdown' | 'badge';
  /** Whether the option is currently selected (only for dropdown) */
  isSelected?: boolean;
  /** Callback to remove the option (only for badge) */
  onRemove?: () => void;
}

/**
 * Props for MultiSelect component
 */
interface MultiSelectProps
  extends Omit<
      React.ButtonHTMLAttributes<HTMLButtonElement>,
      'animationConfig'
    >,
    VariantProps<typeof multiSelectVariants> {
  /**
   * An array of option objects or groups to be displayed in the multi-select component.
   */
  options: MultiSelectOption[] | MultiSelectGroup[];
  /**
   * Callback function triggered when the selected values change.
   * Receives an array of the new selected values.
   */
  onValueChange: (value: string[]) => void;

  /** The default selected values when the component mounts. */
  defaultValue?: string[];

  /**
   * Placeholder content to display when no values are selected.
   * Optional, defaults to "Select options".
   */
  placeholder?: React.ReactNode;

  /**
   * Placeholder text used for assistive technologies describing the trigger button.
   * Optional, defaults to "Select options".
   */
  placeholderAriaLabel?: string;

  /**
   * Screen reader description announced for the trigger button.
   * Optional, defaults to "Multi-select dropdown. Use arrow keys to navigate, Enter to select, and Escape to close.".
   */
  triggerDescription?: React.ReactNode;

  /**
   * Screen reader label announced when no options are selected.
   * Optional, defaults to "No options selected".
   */
  noSelectionLabel?: React.ReactNode;

  /**
   * Assistive text describing how to use the search input.
   * Optional, defaults to "Type to filter options. Use arrow keys to navigate results.".
   */
  searchHelpText?: React.ReactNode;

  /**
   * Accessible label applied to the search input.
   * Optional, defaults to "Search through available options".
   */
  searchAriaLabel?: string;

  /**
   * Accessible label applied to the options list popover.
   * Optional, defaults to "Available options".
   */
  optionsListAriaLabel?: string;

  /**
   * Animation duration in seconds for the visual effects (e.g., bouncing badges).
   * Optional, defaults to 0 (no animation).
   */
  animation?: number;

  /**
   * Advanced animation configuration for different component parts.
   * Optional, allows fine-tuning of various animation effects.
   */
  animationConfig?: AnimationConfig;

  /**
   * Maximum number of items to display. Extra selected items will be summarized.
   * Optional, defaults to 3.
   */
  maxCount?: number;

  /**
   * The modality of the popover. When set to true, interaction with outside elements
   * will be disabled and only popover content will be visible to screen readers.
   * Optional, defaults to false.
   */
  modalPopover?: boolean;

  /**
   * Additional class names to apply custom styles to the multi-select component.
   * Optional, can be used to add custom styles.
   */
  className?: string;

  /**
   * If true, disables the select all functionality.
   * Optional, defaults to false.
   */
  hideSelectAll?: boolean;

  /**
   * If true, shows search functionality in the popover.
   * If false, hides the search input completely.
   * Optional, defaults to true.
   */
  searchable?: boolean;

  /**
   * Custom empty state message when no options match search.
   * Optional, defaults to "No results found."
   */
  emptyIndicator?: React.ReactNode;

  /**
   * Placeholder text shown in the search input when search is enabled.
   * Optional, defaults to "Search options...".
   */
  searchPlaceholder?: string;

  /**
   * Custom label for the select-all option inside the list.
   * Optional, defaults to "Select All".
   */
  selectAllLabel?: React.ReactNode;

  /**
   * Custom label used alongside the total option count when select all is shown.
   * Optional, defaults to "options".
   */
  selectAllCountLabel?: React.ReactNode;

  /**
   * Label displayed when clearing all selected values via the footer action.
   * Optional, defaults to "Clear All".
   */
  clearAllLabel?: React.ReactNode;

  /**
   * Label displayed for the footer apply action.
   * Optional, defaults to "Apply".
   */
  applyLabel?: React.ReactNode;

  /**
   * Label appended to the overflow badge when more selections exist than can be shown.
   * Optional, defaults to "more".
   */
  moreSelectedLabel?: React.ReactNode;

  /**
   * If true, allows the component to grow and shrink with its content.
   * If false, uses fixed width behavior.
   * Optional, defaults to false.
   */
  autoSize?: boolean;

  /**
   * If true, shows badges in a single line with horizontal scroll.
   * If false, badges wrap to multiple lines.
   * Optional, defaults to false.
   */
  singleLine?: boolean;

  /**
   * Custom CSS class for the popover content.
   * Optional, can be used to customize popover appearance.
   */
  popoverClassName?: string;

  /**
   * If true, disables the component completely.
   * Optional, defaults to false.
   */
  disabled?: boolean;

  /**
   * If true, displays the component in an error/invalid state with red border.
   * Optional, defaults to false.
   */
  invalid?: boolean;

  /**
   * Responsive configuration for different screen sizes.
   * Allows customizing maxCount and other properties based on viewport.
   * Can be boolean true for default responsive behavior or an object for custom configuration.
   */
  responsive?:
    | boolean
    | {
        /** Configuration for mobile devices (< 640px) */
        mobile?: {
          maxCount?: number;
          hideIcons?: boolean;
          compactMode?: boolean;
        };
        /** Configuration for tablet devices (640px - 1024px) */
        tablet?: {
          maxCount?: number;
          hideIcons?: boolean;
          compactMode?: boolean;
        };
        /** Configuration for desktop devices (> 1024px) */
        desktop?: {
          maxCount?: number;
          hideIcons?: boolean;
          compactMode?: boolean;
        };
      };

  /**
   * Minimum width for the component.
   * Optional, defaults to auto-sizing based on content.
   * When set, component will not shrink below this width.
   */
  minWidth?: string;

  /**
   * Maximum width for the component.
   * Optional, defaults to 100% of container.
   * Component will not exceed container boundaries.
   */
  maxWidth?: string;

  /**
   * If true, automatically removes duplicate options based on their value.
   * Optional, defaults to false (shows warning in dev mode instead).
   */
  deduplicateOptions?: boolean;

  /**
   * If true, the component will reset its internal state when defaultValue changes.
   * Useful for React Hook Form integration and form reset functionality.
   * Optional, defaults to true.
   */
  resetOnDefaultValueChange?: boolean;

  /**
   * If true, automatically closes the popover after selecting an option.
   * Useful for single-selection-like behavior or mobile UX.
   * Optional, defaults to false.
   */
  closeOnSelect?: boolean;

  /**
   * If true, filters options by both value and label when searching.
   * If false, only filters by label.
   * Optional, defaults to false.
   */
  filterByValueAndLabel?: boolean;

  /**
   * Custom render function for option content.
   * Allows customization of how options appear in both the dropdown and as selected badges.
   * If not provided, uses default rendering with label and optional icon.
   * Optional, defaults to a function that renders the label with remove button for badges.
   */
  renderOption?: (context: RenderOptionContext) => React.ReactNode;
}

/**
 * Imperative methods exposed through ref
 */
export interface MultiSelectRef {
  /**
   * Programmatically reset the component to its default value
   */
  reset: () => void;
  /**
   * Get current selected values
   */
  getSelectedValues: () => string[];
  /**
   * Set selected values programmatically
   */
  setSelectedValues: (values: string[]) => void;
  /**
   * Clear all selected values
   */
  clear: () => void;
  /**
   * Focus the component
   */
  focus: () => void;
}

export const MultiSelect = React.forwardRef<MultiSelectRef, MultiSelectProps>(
  (
    {
      options,
      onValueChange,
      variant,
      defaultValue = [],
      placeholder = '選択してください',
      placeholderAriaLabel = '選択してください',
      triggerDescription = 'マルチセレクトドロップダウン。矢印キーでナビゲート、Enterで選択、Escapeで閉じます。',
      noSelectionLabel = 'オプションが選択されていません',
      searchHelpText = '入力してオプションをフィルタリング。矢印キーで結果をナビゲート。',
      searchAriaLabel = '利用可能なオプションを検索',
      optionsListAriaLabel = '利用可能なオプション',
      selectAllLabel = 'すべて選択',
      selectAllCountLabel = 'オプション',
      clearAllLabel = 'すべてクリア',
      applyLabel = '適用',
      moreSelectedLabel = 'その他',
      searchPlaceholder = 'オプションを検索...',
      animation = 0,
      animationConfig,
      maxCount = 10,
      modalPopover = false,
      className,
      hideSelectAll = false,
      searchable = true,
      emptyIndicator = '結果が見つかりません。',
      autoSize = false,
      singleLine = false,
      popoverClassName,
      disabled = false,
      invalid = false,
      responsive,
      minWidth,
      maxWidth,
      deduplicateOptions = false,
      resetOnDefaultValueChange = true,
      closeOnSelect = false,
      filterByValueAndLabel = false,
      renderOption,
      ...props
    },
    ref
  ) => {
    const [selectedValues, setSelectedValues] =
      React.useState<string[]>(defaultValue);
    const [isPopoverOpen, setIsPopoverOpen] = React.useState(false);
    const [isAnimating, setIsAnimating] = React.useState(false);
    const [searchValue, setSearchValue] = React.useState('');

    const [politeMessage, setPoliteMessage] = React.useState('');
    const [assertiveMessage, setAssertiveMessage] = React.useState('');
    const prevSelectedCount = React.useRef(selectedValues.length);
    const prevIsOpen = React.useRef(isPopoverOpen);
    const prevSearchValue = React.useRef(searchValue);

    const announce = React.useCallback(
      (message: string, priority: 'polite' | 'assertive' = 'polite') => {
        if (priority === 'assertive') {
          setAssertiveMessage(message);
          setTimeout(() => setAssertiveMessage(''), 100);
        } else {
          setPoliteMessage(message);
          setTimeout(() => setPoliteMessage(''), 100);
        }
      },
      []
    );

    const multiSelectId = React.useId();
    const listboxId = `${multiSelectId}-listbox`;
    const triggerDescriptionId = `${multiSelectId}-description`;
    const selectedCountId = `${multiSelectId}-count`;

    const prevDefaultValueRef = React.useRef<string[]>(defaultValue);

    const isGroupedOptions = React.useCallback(
      (
        opts: MultiSelectOption[] | MultiSelectGroup[]
      ): opts is MultiSelectGroup[] => {
        const first = opts[0];
        return Boolean(
          first && typeof first === 'object' && 'heading' in first
        );
      },
      []
    );

    const arraysEqual = React.useCallback(
      (a: string[], b: string[]): boolean => {
        if (a.length !== b.length) return false;
        const sortedA = [...a].sort();
        const sortedB = [...b].sort();
        return sortedA.every((val, index) => val === sortedB[index]);
      },
      []
    );

    const resetToDefault = React.useCallback(() => {
      setSelectedValues(defaultValue);
      setIsPopoverOpen(false);
      setSearchValue('');
      onValueChange(defaultValue);
    }, [defaultValue, onValueChange]);

    const buttonRef = React.useRef<HTMLButtonElement>(null);

    React.useImperativeHandle(
      ref,
      () => ({
        reset: resetToDefault,
        getSelectedValues: () => selectedValues,
        setSelectedValues: (values: string[]) => {
          setSelectedValues(values);
          onValueChange(values);
        },
        clear: () => {
          setSelectedValues([]);
          onValueChange([]);
        },
        focus: () => {
          if (buttonRef.current) {
            buttonRef.current.focus();
            const originalOutline = buttonRef.current.style.outline;
            const originalOutlineOffset = buttonRef.current.style.outlineOffset;
            buttonRef.current.style.outline = '2px solid hsl(var(--ring))';
            buttonRef.current.style.outlineOffset = '2px';
            setTimeout(() => {
              if (buttonRef.current) {
                buttonRef.current.style.outline = originalOutline;
                buttonRef.current.style.outlineOffset = originalOutlineOffset;
              }
            }, 1000);
          }
        },
      }),
      [resetToDefault, selectedValues, onValueChange]
    );

    const [screenSize, setScreenSize] = React.useState<
      'mobile' | 'tablet' | 'desktop'
    >('desktop');

    React.useEffect(() => {
      if (typeof window === 'undefined') return;
      const handleResize = () => {
        const width = window.innerWidth;
        if (width < 640) {
          setScreenSize('mobile');
        } else if (width < 1024) {
          setScreenSize('tablet');
        } else {
          setScreenSize('desktop');
        }
      };
      handleResize();
      window.addEventListener('resize', handleResize);
      return () => {
        if (typeof window !== 'undefined') {
          window.removeEventListener('resize', handleResize);
        }
      };
    }, []);

    const getResponsiveSettings = () => {
      if (!responsive) {
        return {
          maxCount: maxCount,
          hideIcons: false,
          compactMode: false,
        };
      }
      if (responsive === true) {
        const defaultResponsive = {
          mobile: { maxCount: 2, hideIcons: false, compactMode: true },
          tablet: { maxCount: 4, hideIcons: false, compactMode: false },
          desktop: { maxCount: 6, hideIcons: false, compactMode: false },
        };
        const currentSettings = defaultResponsive[screenSize];
        return {
          maxCount: currentSettings?.maxCount ?? maxCount,
          hideIcons: currentSettings?.hideIcons ?? false,
          compactMode: currentSettings?.compactMode ?? false,
        };
      }
      const currentSettings = responsive[screenSize];
      return {
        maxCount: currentSettings?.maxCount ?? maxCount,
        hideIcons: currentSettings?.hideIcons ?? false,
        compactMode: currentSettings?.compactMode ?? false,
      };
    };

    const responsiveSettings = getResponsiveSettings();

    const getBadgeAnimationClass = () => {
      if (animationConfig?.badgeAnimation) {
        switch (animationConfig.badgeAnimation) {
          case 'bounce':
            return isAnimating
              ? 'animate-bounce'
              : 'hover:-translate-y-1 hover:scale-110';
          case 'pulse':
            return 'hover:animate-pulse';
          case 'fade':
            return 'hover:opacity-80';
          case 'slide':
            return 'hover:translate-x-1';
          case 'none':
            return '';
          default:
            return '';
        }
      }
      return isAnimating ? 'animate-bounce' : '';
    };

    const getPopoverAnimationClass = () => {
      if (animationConfig?.popoverAnimation) {
        switch (animationConfig.popoverAnimation) {
          case 'scale':
            return 'animate-scaleIn';
          case 'slide':
            return 'animate-slideInDown';
          case 'fade':
            return 'animate-fadeIn';
          case 'flip':
            return 'animate-flipIn';
          case 'none':
            return '';
          default:
            return '';
        }
      }
      return '';
    };

    const getAllOptions = React.useCallback((): MultiSelectOption[] => {
      if (options.length === 0) return [];
      let allOptions: MultiSelectOption[];
      if (isGroupedOptions(options)) {
        allOptions = options.flatMap((group) => group.options);
      } else {
        allOptions = options;
      }
      const valueSet = new Set<string>();
      const duplicates: string[] = [];
      const uniqueOptions: MultiSelectOption[] = [];
      allOptions.forEach((option) => {
        if (valueSet.has(option.value)) {
          duplicates.push(option.value);
          if (!deduplicateOptions) {
            uniqueOptions.push(option);
          }
        } else {
          valueSet.add(option.value);
          uniqueOptions.push(option);
        }
      });
      if (process.env.NODE_ENV === 'development' && duplicates.length > 0) {
        const action = deduplicateOptions
          ? 'automatically removed'
          : 'detected';
        console.warn(
          `MultiSelect: Duplicate option values ${action}: ${duplicates.join(
            ', '
          )}. ` +
            `${
              deduplicateOptions
                ? 'Duplicates have been removed automatically.'
                : "This may cause unexpected behavior. Consider setting 'deduplicateOptions={true}' or ensure all option values are unique."
            }`
        );
      }
      return deduplicateOptions ? uniqueOptions : allOptions;
    }, [options, deduplicateOptions, isGroupedOptions]);

    const getOptionByValue = React.useCallback(
      (value: string): MultiSelectOption | undefined => {
        const option = getAllOptions().find((option) => option.value === value);
        if (!option && process.env.NODE_ENV === 'development') {
          console.warn(
            `MultiSelect: Option with value "${value}" not found in options list`
          );
        }
        return option;
      },
      [getAllOptions]
    );

    const filterItems = React.useCallback(
      (value: string, search: string) => {
        const [optionValue, label] = value.split(':');

        if (!filterByValueAndLabel) {
          // Only filter by label
          if (label && label.toLowerCase().includes(search.toLowerCase())) {
            return 1;
          }
          return 0;
        }

        // Filter by both value and label
        const searchLower = search.toLowerCase();
        if (
          (label && label.toLowerCase().includes(searchLower)) ||
          (optionValue && optionValue.toLowerCase().includes(searchLower))
        ) {
          return 1;
        }
        return 0;
      },
      [filterByValueAndLabel]
    );

    const handleInputKeyDown = (
      event: React.KeyboardEvent<HTMLInputElement>
    ) => {
      if (event.key === 'Enter') {
        setIsPopoverOpen(true);
      } else if (event.key === 'Backspace' && !event.currentTarget.value) {
        const newSelectedValues = [...selectedValues];
        newSelectedValues.pop();
        setSelectedValues(newSelectedValues);
        onValueChange(newSelectedValues);
      }
    };

    const toggleOption = (optionValue: string) => {
      if (disabled) return;
      const option = getOptionByValue(optionValue);
      if (option?.disabled) return;
      const newSelectedValues = selectedValues.includes(optionValue)
        ? selectedValues.filter((value) => value !== optionValue)
        : [...selectedValues, optionValue];
      setSelectedValues(newSelectedValues);
      onValueChange(newSelectedValues);
      if (closeOnSelect) {
        setIsPopoverOpen(false);
      }
    };

    const handleClear = () => {
      if (disabled) return;
      setSelectedValues([]);
      onValueChange([]);
    };

    const handleTogglePopover = () => {
      if (disabled) return;
      setIsPopoverOpen((prev) => !prev);
    };

    const clearExtraOptions = () => {
      if (disabled) return;
      const newSelectedValues = selectedValues.slice(
        0,
        responsiveSettings.maxCount
      );
      setSelectedValues(newSelectedValues);
      onValueChange(newSelectedValues);
    };

    const toggleAll = () => {
      if (disabled) return;
      const allOptions = getAllOptions().filter((option) => !option.disabled);
      if (selectedValues.length === allOptions.length) {
        handleClear();
      } else {
        const allValues = allOptions.map((option) => option.value);
        setSelectedValues(allValues);
        onValueChange(allValues);
      }

      if (closeOnSelect) {
        setIsPopoverOpen(false);
      }
    };

    const renderOptionIconNode = (option: MultiSelectOption) => {
      if (!option.icon) {
        return null;
      }

      const customStyle = option.style;

      return (
        <span
          aria-hidden="true"
          className="mr-2 text-body-secondary flex items-center"
          style={
            customStyle?.iconColor
              ? { color: customStyle.iconColor }
              : undefined
          }
        >
          {renderIcon(option.icon, {
            className: 'h-4 w-4',
          })}
        </span>
      );
    };

    // Default render function that maintains current behavior
    const defaultRenderOption = (
      context: RenderOptionContext
    ): React.ReactNode => {
      const { option, location, onRemove } = context;

      if (location === 'badge') {
        // Render as selected badge with full Tag component styling
        const customStyle = option.style;
        const badgeStyle: React.CSSProperties = {
          animationDuration: `${animation}s`,
          ...(customStyle?.badgeColor && {
            backgroundColor: customStyle.badgeColor,
          }),
          ...(customStyle?.gradient && {
            background: customStyle.gradient,
            color: 'white',
          }),
        };

        return (
          <Tag
            className={cn(
              getBadgeAnimationClass(),
              multiSelectVariants({ variant }),
              customStyle?.gradient && 'border-transparent',
              responsiveSettings.compactMode && 'text-xs px-1.5 py-0.5',
              screenSize === 'mobile' && 'max-w-[120px] truncate',
              singleLine && 'flex-shrink-0 whitespace-nowrap',
              '[&>svg]:pointer-events-auto'
            )}
            style={badgeStyle}
            onRemove={onRemove!}
          >
            {option.label}
          </Tag>
        );
      }

      // Render in dropdown
      return (
        <>
          {renderOptionIconNode(option)}
          <span>{option.label}</span>
        </>
      );
    };

    // Use provided renderOption or fall back to default
    const effectiveRenderOption = renderOption || defaultRenderOption;

    React.useEffect(() => {
      if (!resetOnDefaultValueChange) return;
      const prevDefaultValue = prevDefaultValueRef.current;
      if (!arraysEqual(prevDefaultValue, defaultValue)) {
        if (!arraysEqual(selectedValues, defaultValue)) {
          setSelectedValues(defaultValue);
        }
        prevDefaultValueRef.current = [...defaultValue];
      }
    }, [defaultValue, selectedValues, arraysEqual, resetOnDefaultValueChange]);

    const getWidthConstraints = () => {
      const defaultMinWidth = screenSize === 'mobile' ? '0px' : '200px';
      const effectiveMinWidth = minWidth || defaultMinWidth;
      const effectiveMaxWidth = maxWidth || '100%';
      return {
        minWidth: effectiveMinWidth,
        maxWidth: effectiveMaxWidth,
        width: autoSize ? 'auto' : '100%',
      };
    };

    const widthConstraints = getWidthConstraints();

    React.useEffect(() => {
      if (!isPopoverOpen) {
        setSearchValue('');
      }
    }, [isPopoverOpen]);

    React.useEffect(() => {
      const selectedCount = selectedValues.length;
      const allOptions = getAllOptions();
      const totalOptions = allOptions.filter((opt) => !opt.disabled).length;
      if (selectedCount !== prevSelectedCount.current) {
        const diff = selectedCount - prevSelectedCount.current;
        if (diff > 0) {
          const addedItems = selectedValues.slice(-diff);
          const addedLabels = addedItems
            .map(
              (value) => allOptions.find((opt) => opt.value === value)?.label
            )
            .filter(Boolean);

          if (addedLabels.length === 1) {
            announce(
              `${addedLabels[0]} selected. ${selectedCount} of ${totalOptions} options selected.`
            );
          } else {
            announce(
              `${addedLabels.length} options selected. ${selectedCount} of ${totalOptions} total selected.`
            );
          }
        } else if (diff < 0) {
          announce(
            `Option removed. ${selectedCount} of ${totalOptions} options selected.`
          );
        }
        prevSelectedCount.current = selectedCount;
      }

      if (isPopoverOpen !== prevIsOpen.current) {
        if (isPopoverOpen) {
          announce(
            `Dropdown opened. ${totalOptions} options available. Use arrow keys to navigate.`
          );
        } else {
          announce('Dropdown closed.');
        }
        prevIsOpen.current = isPopoverOpen;
      }

      if (
        searchValue !== prevSearchValue.current &&
        searchValue !== undefined
      ) {
        if (searchValue && isPopoverOpen) {
          // Command handles filtering, so we can't easily get the count
          // Just announce that search is active
          announce(`Searching for "${searchValue}"`);
        }
        prevSearchValue.current = searchValue;
      }
    }, [selectedValues, isPopoverOpen, searchValue, announce, getAllOptions]);

    return (
      <>
        <div className="sr-only">
          <div aria-live="polite" aria-atomic="true" role="status">
            {politeMessage}
          </div>
          <div aria-live="assertive" aria-atomic="true" role="alert">
            {assertiveMessage}
          </div>
        </div>

        <Popover
          open={isPopoverOpen}
          onOpenChange={setIsPopoverOpen}
          modal={modalPopover}
        >
          <div id={triggerDescriptionId} className="sr-only">
            {triggerDescription}
          </div>
          <div id={selectedCountId} className="sr-only" aria-live="polite">
            {selectedValues.length === 0
              ? noSelectionLabel
              : `${selectedValues.length} option${
                  selectedValues.length === 1 ? '' : 's'
                } selected: ${selectedValues
                  .map((value) => getOptionByValue(value)?.label)
                  .filter(Boolean)
                  .join(', ')}`}
          </div>

          <div className={cn(autoSize && 'w-auto', className)}>
            <PopoverTrigger asChild>
              <button
                ref={buttonRef}
                {...props}
                onClick={handleTogglePopover}
                disabled={disabled}
                className={cn(
                  `focus:ring-interactive-focused border-interactive-default
                  bg-surface-primary hover:border-interactive-hover px-0
                  has-[:disabled]:border-interactive-disabled
                  has-[:disabled]:bg-surface-disabled
                  has-[:focus]:ring-interactive-focused h-12 rounded relative
                  flex w-full items-center border focus:ring-4
                  focus-visible:outline-none
                  has-[:focus-visible]:border-[var(--chemican-green-800)]
                  has-[:focus-visible]:ring-4 has-[:focus-visible]:outline-0`,
                  autoSize ? 'w-auto' : 'w-full',
                  isPopoverOpen &&
                    !invalid &&
                    'ring-interactive-focused ring-4',
                  isPopoverOpen &&
                    invalid &&
                    'ring-interactive-alert-focused ring-4',
                  responsiveSettings.compactMode && 'min-h-8 text-sm',
                  screenSize === 'mobile' && 'min-h-12',
                  disabled && 'cursor-not-allowed opacity-50',
                  invalid &&
                    `border-interactive-alert-default!
                    focus:ring-interactive-alert-focused`
                )}
                style={{
                  ...widthConstraints,
                  maxWidth: `min(${widthConstraints.maxWidth}, 100%)`,
                }}
                role="combobox"
                aria-expanded={isPopoverOpen}
                aria-haspopup="listbox"
                aria-controls={isPopoverOpen ? listboxId : undefined}
                aria-describedby={`${triggerDescriptionId} ${selectedCountId}`}
                aria-label={`Multi-select: ${selectedValues.length} of ${
                  getAllOptions().length
                } options selected. ${placeholderAriaLabel}`}
              >
                {selectedValues.length > 0 && (
                  <>
                    {/*
                      NOTE: This logic to show count and clear button in the trigger
                      is disabled for now to simplify the UI. It can be re-enabled
                      in the future if needed.

                  <div className="flex items-center justify-between">
                    <div
                      role="button"
                      tabIndex={0}
                      onClick={(event) => {
                        event.stopPropagation();
                        handleClear();
                      }}
                      onKeyDown={(event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                          event.preventDefault();
                          event.stopPropagation();
                          handleClear();
                        }
                      }}
                      aria-label={`Clear all ${selectedValues.length} selected options`}
                      className="h-4 w-4 mx-2 text-body-secondary
                        hover:text-body-primary focus:ring-interactive-focused
                        rounded-sm flex cursor-pointer items-center
                        justify-center focus:ring-2 focus:ring-offset-1
                        focus:outline-none"
                    >
                      <IconX className="h-4 w-4" />
                    </div>
                    <Separator
                      orientation="vertical"
                      className="min-h-6 flex h-full"
                    />
                    <IconChevronDown
                      className="h-4 mx-2 text-body-secondary cursor-pointer"
                      aria-hidden="true"
                    />
                  </div>
                  */}
                  </>
                )}
                <div
                  className="mx-auto flex w-full items-center justify-between"
                >
                  <span className="text-body-primary mx-3">{placeholder}</span>
                  <IconChevronDown
                    className="h-4 text-body-primary mx-2 cursor-pointer"
                  />
                </div>
              </button>
            </PopoverTrigger>
            <div className="gap-1 mt-xxs flex flex-wrap">
              {selectedValues
                .slice(0, responsiveSettings.maxCount)
                .map((value) => {
                  const option = getOptionByValue(value);
                  if (!option) {
                    return null;
                  }

                  // Always use the render function (either custom or default)
                  return (
                    <div key={value}>
                      {effectiveRenderOption({
                        option,
                        location: 'badge',
                        onRemove: () => toggleOption(value),
                      })}
                    </div>
                  );
                })
                .filter(Boolean)}
              {selectedValues.length > responsiveSettings.maxCount && (
                <Tag
                  className={cn(
                    `text-body-primary border-divider-default bg-transparent
                    hover:bg-transparent`,
                    getBadgeAnimationClass(),
                    multiSelectVariants({ variant }),
                    responsiveSettings.compactMode && 'text-xs px-1.5 py-0.5',
                    singleLine && 'flex-shrink-0 whitespace-nowrap',
                    '[&>svg]:pointer-events-auto'
                  )}
                  onRemove={clearExtraOptions}
                >
                  + {selectedValues.length - responsiveSettings.maxCount}{' '}
                  {moreSelectedLabel}
                </Tag>
              )}
            </div>
          </div>
          <PopoverContent
            id={listboxId}
            role="listbox"
            aria-multiselectable="true"
            aria-label={optionsListAriaLabel}
            className={cn(
              'p-0 w-auto',
              getPopoverAnimationClass(),
              screenSize === 'mobile' && 'w-[85vw] max-w-[280px]',
              screenSize === 'tablet' && 'max-w-md w-[70vw]',
              screenSize === 'desktop' && 'min-w-[300px]',
              popoverClassName
            )}
            style={{
              animationDuration: `${animationConfig?.duration || animation}s`,
              animationDelay: `${animationConfig?.delay || 0}s`,
              maxWidth: `min(${widthConstraints.maxWidth}, 85vw)`,
              maxHeight: screenSize === 'mobile' ? '70vh' : '60vh',
              touchAction: 'manipulation',
            }}
            align="start"
          >
            <Command filter={filterItems}>
              {searchable && (
                <CommandInput
                  placeholder={searchPlaceholder}
                  onKeyDown={handleInputKeyDown}
                  value={searchValue}
                  onValueChange={setSearchValue}
                  aria-label={searchAriaLabel}
                  aria-describedby={`${multiSelectId}-search-help`}
                />
              )}
              {searchable && (
                <div id={`${multiSelectId}-search-help`} className="sr-only">
                  {searchHelpText}
                </div>
              )}
              <CommandList
                className={cn(
                  'max-h-[40vh] overflow-y-auto',
                  screenSize === 'mobile' && 'max-h-[50vh]'
                )}
                style={{ overscrollBehaviorY: 'contain' }}
              >
                <CommandEmpty>{emptyIndicator}</CommandEmpty>
                {!hideSelectAll && !searchValue && (
                  <CommandGroup>
                    <CommandItem
                      key="all"
                      value="select-all"
                      onSelect={toggleAll}
                      role="option"
                      aria-selected={
                        selectedValues.length ===
                        getAllOptions().filter((opt) => !opt.disabled).length
                      }
                      aria-label={`Select all ${
                        getAllOptions().length
                      } options`}
                      className="cursor-pointer"
                    >
                      <Checkbox
                        className="mr-2"
                        checked={
                          selectedValues.length ===
                          getAllOptions().filter((opt) => !opt.disabled).length
                        }
                      />
                      <span>
                        ({selectAllLabel}
                        {getAllOptions().length > 20 ? (
                          <>
                            {' - '}
                            {getAllOptions().length} {selectAllCountLabel}
                          </>
                        ) : null}
                        )
                      </span>
                    </CommandItem>
                  </CommandGroup>
                )}
                {isGroupedOptions(options) ? (
                  options.map((group) => (
                    <CommandGroup key={group.heading} heading={group.heading}>
                      {group.options.map((option) => {
                        const isSelected = selectedValues.includes(
                          option.value
                        );
                        return (
                          <CommandItem
                            key={option.value}
                            value={`${option.value}:${option.label}`}
                            onSelect={() => toggleOption(option.value)}
                            role="option"
                            aria-selected={isSelected}
                            aria-disabled={option.disabled ?? false}
                            aria-label={`${option.label}${
                              isSelected ? ', selected' : ', not selected'
                            }${option.disabled ? ', disabled' : ''}`}
                            className={cn(
                              'cursor-pointer',
                              option.disabled && 'cursor-not-allowed opacity-50'
                            )}
                            disabled={Boolean(option.disabled)}
                          >
                            <Checkbox className="mr-2" checked={isSelected} />
                            {effectiveRenderOption({
                              option,
                              location: 'dropdown',
                              isSelected,
                            })}
                          </CommandItem>
                        );
                      })}
                    </CommandGroup>
                  ))
                ) : (
                  <CommandGroup>
                    {options.map((option) => {
                      const isSelected = selectedValues.includes(option.value);
                      return (
                        <CommandItem
                          key={option.value}
                          value={`${option.value}:${option.label}`}
                          onSelect={() => toggleOption(option.value)}
                          role="option"
                          aria-selected={isSelected}
                          aria-disabled={option.disabled ?? false}
                          aria-label={`${option.label}${
                            isSelected ? ', selected' : ', not selected'
                          }${option.disabled ? ', disabled' : ''}`}
                          className={cn(
                            'cursor-pointer',
                            option.disabled && 'cursor-not-allowed opacity-50'
                          )}
                          disabled={Boolean(option.disabled)}
                        >
                          <Checkbox className="mr-2" checked={isSelected} />
                          {effectiveRenderOption({
                            option,
                            location: 'dropdown',
                            isSelected,
                          })}
                        </CommandItem>
                      );
                    })}
                  </CommandGroup>
                )}
              </CommandList>
              <CommandSeparator />
              <div
                className="px-md py-sm bg-surface-primary bottom-0 sticky flex
                  items-center justify-between"
              >
                <>
                  <Button
                    intent="text"
                    size="xs"
                    className="min-w-auto"
                    onClick={handleClear}
                    disabled={selectedValues.length === 0}
                  >
                    {clearAllLabel}
                  </Button>
                  <Button
                    intent="primary"
                    size="xs"
                    className="min-w-auto"
                    onClick={() => setIsPopoverOpen(false)}
                  >
                    {applyLabel}
                  </Button>
                </>
              </div>
            </Command>
          </PopoverContent>
          {animation > 0 && selectedValues.length > 0 && (
            <IconSparkles
              className={cn(
                `my-2 text-body-primary bg-surface-primary w-3 h-3
                cursor-pointer`,
                isAnimating ? '' : 'text-body-secondary'
              )}
              onClick={() => setIsAnimating(!isAnimating)}
            />
          )}
        </Popover>
      </>
    );
  }
);

MultiSelect.displayName = 'MultiSelect';
export type { MultiSelectOption, MultiSelectGroup, MultiSelectProps };
