const fs = require('fs');
const path = require('path');

// Input CSS file (modify the filename as needed)
const inputFile = path.join(__dirname, '../src/tokens/source.css');
const outputFile = path.join(__dirname, '../src/styles/variables.css');
const jsonOutputFile = path.join(__dirname, '../src/tokens.json');

const categories = [
  'color-background',
  'color-text',
  'color-border',
  'spacing',
  'text-size',
  'radius',
];

// Map to help mapping the tokens to tailwind theme namespaces.
// This is so we can restrict utility classes to their intended property only.
// Furthemore, it will collapse the utility classnames quite a bit.
const tailwindThemeVariableMap = {
  'color-background': 'background-color',
  'color-text': 'text-color',
  'color-border': 'border-color',
  'color-ring': 'ring-color',
  'elevation-shadow': 'box-shadow',
  'font-size': 'text',
};

const baseFontSize = 16;

const convertPxtoRem = (px) => {
  const remValue = parseInt(px) / baseFontSize;
  return Number.isInteger(remValue)
    ? `${remValue}rem`
    : `${parseFloat(remValue.toFixed(3))}rem`;
};

const isPixelValue = (value) => {
  return value.endsWith('px');
};

const mapTokenToTailwindThemeVariables = (token) => {
  for (const [key, value] of Object.entries(tailwindThemeVariableMap)) {
    if (token.slice(2).startsWith(key)) {
      return `--${value}${token.slice(2 + key.length)}`;
    }
  }
  return token;
};

fs.readFile(inputFile, 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }

  const lines = data.split('\n');
  const themes = {};
  const primitives = {};
  let currentTheme = null;

  lines.forEach((line) => {
    line = line.trim();

    if (line.startsWith('[data-theme=')) {
      // Extract theme name, removing quotes and brackets
      const themeMatch = line.match(/\[data-theme=['"]([^'"]+)['"]\]/);
      if (themeMatch) {
        currentTheme = themeMatch[1].replace(' [Default]', ''); // Remove "[Default]"
        if (currentTheme !== 'Primitive') {
          themes[currentTheme] = {};
        }
      }
    } else if (currentTheme && line.startsWith('--')) {
      // Extract variable assignment
      const [key, value] = line
        .split(':')
        .map((s) => s.trim().replace(';', ''));
      if (currentTheme === 'Primitive') {
        primitives[key] = isPixelValue(value) ? convertPxtoRem(value) : value;
      } else {
        themes[currentTheme][key] = isPixelValue(value)
          ? convertPxtoRem(value)
          : value;
      }
    }
  });

  // Extract the default theme (first one marked with `[Default]`)
  const defaultThemeName = Object.keys(themes)[0];

  // Build the output
  result =
    '/*\nThis file is generated from the source tokens file coming from Figma.\nDo not edit this file directly!\n*/\n\n';

  // @theme inline block
  result += '@theme inline {\n';
  // Add the color reset to remove tailwinds default colors
  result +=
    '  --color-*: initial;\n  --text-*: initial;\n  --spacing-*: initial;\n\n';

  // Add the `--spacing` unit, which should be base size / 4
  result += `  --spacing: ${convertPxtoRem(baseFontSize / 4)};\n\n`;

  Object.keys(themes[defaultThemeName]).forEach((token) => {
    result += `  ${mapTokenToTailwindThemeVariables(token)}: var(--token-${token.slice(2)});\n`;
  });
  // Save border-colors also as ring-colors
  Object.keys(themes[defaultThemeName])
    .filter((token) => token.startsWith('--color-border'))
    .forEach((token) => {
      result += `  --ring-color${token.slice(14)}: var(--token-${token.slice(2)});\n`;
    });

  result += '}\n\n';

  // @layer base block
  result += '@layer base {\n';
  result += '  :root {\n';
  Object.entries(primitives).forEach(([key, value]) => {
    result += `    ${key}: ${value};\n`;
  });
  result += '  }\n\n';

  // Add only valid themes (excluding "Primitive")
  Object.entries(themes).forEach(([themeName, tokens]) => {
    if (themeName === defaultThemeName) {
      result += '  :root:not([data-theme]) {\n';
    } else {
      result += `  [data-theme='${themeName}'] {\n`;
    }
    Object.entries(tokens).forEach(([token, value]) => {
      result += `    --token-${token.slice(2)}: ${value};\n`;
    });
    result += '  }\n\n';
  });

  result += '}\n';

  // Prepare JSON structure
  const jsonResult = {};

  Object.entries({ ...themes, Primitives: primitives }).forEach(
    ([themeName, tokens]) => {
      jsonResult[themeName] = {};
      Object.entries(tokens)
        .sort(([a], [b]) => a.localeCompare(b))
        .forEach(([token, value]) => {
        const category = categories.find((key) => token.includes(key));
        if (category) {
          if (!jsonResult[themeName][category]) {
            jsonResult[themeName][category] = {};
          }
          jsonResult[themeName][category][token] = value;
        } else {
          if (!jsonResult[themeName]['other']) {
            jsonResult[themeName]['other'] = {};
          }
          jsonResult[themeName]['other'][token] = value;
        }
      });
    }
  );

  // Write JSON to file
  fs.writeFile(
    jsonOutputFile,
    JSON.stringify(jsonResult, null, 2),
    'utf8',
    (err) => {
      if (err) {
        console.error('Error writing JSON file:', err);
      } else {
        console.log('Token JSON saved to', jsonOutputFile);
      }
    }
  );
  fs.writeFile(outputFile, result, 'utf8', (err) => {
    if (err) {
      console.error('Error writing file:', err);
    } else {
      console.log('Formatted tokens saved to', outputFile);
    }
  });
});
