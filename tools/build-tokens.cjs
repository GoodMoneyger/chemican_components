const fs = require('fs');
const path = require('path');

// Input CSS file (modify the filename as needed)
const inputFile = path.join(__dirname, '../src/tokens/source.css');
const outputFile = path.join(__dirname, '../src/styles/variables.css');
const tsOutputFile = path.join(__dirname, '../src/tokens.ts');

const categories = [
  'color-background',
  'color-text',
  'color-border',
  'color-shape',
  'spacing',
  'text-size',
  'radius',
];

// Map to help mapping the tokens to tailwind theme namespaces.
// This is so we can restrict utility classes to their intended property only.
// Furthemore, it will collapse the utility classnames quite a bit.
const tailwindThemeVariableMap = {
  'color-background': 'background-color',
  'color-text': 'text-color',
  'color-border': 'border-color',
  'color-ring': 'ring-color',
  'elevation-shadow': 'box-shadow',
  'text-size': 'text',
};

const baseFontSize = 16;

const convertPxtoRem = (px) => {
  const remValue = parseInt(px) / baseFontSize;
  return Number.isInteger(remValue)
    ? `${remValue}rem`
    : `${parseFloat(remValue.toFixed(3))}rem`;
};

const isPixelValue = (value) => {
  return value.endsWith('px');
};

const mapTokenToTailwindThemeVariables = (token) => {
  for (const [key, value] of Object.entries(tailwindThemeVariableMap)) {
    if (token.slice(2).startsWith(key)) {
      return `--${value}${token.slice(2 + key.length)}`;
    }
  }
  return token;
};

fs.readFile(inputFile, 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }

  const lines = data.split('\n');
  const themes = {};
  const primitives = {};
  let currentTheme = null;

  lines.forEach((line) => {
    line = line.trim();

    if (line.startsWith('[data-theme=')) {
      // Extract theme name, removing quotes and brackets
      const themeMatch = line.match(/\[data-theme=['"]([^'"]+)['"]\]/);
      if (themeMatch) {
        currentTheme = themeMatch[1].replace(' [Default]', ''); // Remove "[Default]"
        if (currentTheme !== 'Primitive') {
          themes[currentTheme] = {};
        }
      }
    } else if (currentTheme && line.startsWith('--')) {
      // Extract variable assignment
      const [key, value] = line
        .split(':')
        .map((s) => s.trim().replace(';', ''));
      if (currentTheme === 'Primitive') {
        primitives[key] = isPixelValue(value) ? convertPxtoRem(value) : value;
      } else {
        themes[currentTheme][key] = isPixelValue(value)
          ? convertPxtoRem(value)
          : value;
      }
    }
  });

  // Extract the default theme (first one marked with `[Default]`)
  const defaultThemeName = Object.keys(themes)[0];

  // Build the output
  result =
    '/*\nWARNING: This file is generated from the source tokens file coming from Figma.\nDo not edit this file directly!\n*/\n\n';

  // @theme inline block
  result += '@theme inline {\n';
  // Add the color reset to remove tailwinds default colors
  result +=
    '  --color-*: initial;\n  --text-*: initial;\n  --spacing-*: initial;\n\n';

  // Add the `--spacing` unit, which should be base size / 4
  result += `  --spacing: ${convertPxtoRem(baseFontSize / 4)};\n\n`;

  Object.keys(themes[defaultThemeName]).forEach((token) => {
    result += `  ${mapTokenToTailwindThemeVariables(token)}: var(--token-${token.slice(2)});\n`;
  });
  // Save border-colors also as ring-colors
  Object.keys(themes[defaultThemeName])
    .filter((token) => token.startsWith('--color-border'))
    .forEach((token) => {
      result += `  --ring-color${token.slice(14)}: var(--token-${token.slice(2)});\n`;
    });

  result += '}\n\n';

  // @layer base block
  result += '@layer base {\n';
  result += '  :root {\n';
  Object.entries(primitives).forEach(([key, value]) => {
    result += `    ${key}: ${value};\n`;
  });
  result += '  }\n\n';

  // Add only valid themes (excluding "Primitive")
  Object.entries(themes).forEach(([themeName, tokens]) => {
    if (themeName === defaultThemeName) {
      result += '  :root:not([data-theme]) {\n';
    } else {
      result += `  [data-theme='${themeName}'] {\n`;
    }
    Object.entries(tokens).forEach(([token, value]) => {
      result += `    --token-${token.slice(2)}: ${value};\n`;
    });
    result += '  }\n\n';
  });

  result += '}\n';

  // Prepare TypeScript module content
  let tsResult = `// WARNING: This file is generated from the source tokens file coming from Figma.\n`;
  tsResult += `// Do not edit this file directly!\n\n`;
  tsResult += `export interface TokenCategory {\n`;
  tsResult += `  [token: string]: string;\n`;
  tsResult += `}\n\n`;
  tsResult += `export interface ThemeTokens {\n`;
  categories.forEach((category) => {
    tsResult += `  '${category}': TokenCategory;\n`;
  });
  tsResult += `}\n\n`;
  tsResult += 'export interface PrimitiveTokens {\n';
  tsResult += `  'other': TokenCategory;\n`;
  tsResult += `}\n\n`;
  categories.forEach((category) => {
    const pascalCaseCategory = category
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
    tsResult += `export enum ${pascalCaseCategory}Tokens {\n`;
    Object.entries({ ...themes, Primitives: primitives }).forEach(
      ([themeName, tokens]) => {
        Object.keys(tokens)
          .filter((token) => token.includes(category))
          .forEach((token) => {
            const tokenName = token
              .slice(2 + category.length)
              .replace(/-./g, (x) => x[1].toUpperCase());
            tsResult += `  ${tokenName} = '--token-${token.slice(2)}',\n`;
          });
      }
    );
    tsResult += `}\n\n`;
  });

  tsResult += `export interface Tokens {\n`;
  Object.keys(themes).forEach((themeName) => {
    tsResult += `  '${themeName}': ThemeTokens;\n`;
  });
  tsResult += `  'Primitives': PrimitiveTokens;\n`;
  tsResult += `}\n\n`;
  tsResult += `export const tokens: Tokens = {\n`;

  let currentCategory = null;
  Object.entries({ ...themes, Primitives: primitives }).forEach(
    ([themeName, tokens]) => {
      tsResult += `  '${themeName}': {\n`;
      Object.entries(tokens)
        .sort(([a], [b]) => a.localeCompare(b))
        .forEach(([token, value]) => {
          const category = categories.find((key) => token.includes(key));
          const tokenName =
            themeName === 'Primitives' ? token : `--token-${token.slice(2)}`;
          if (category) {
            if (currentCategory !== category) {
              if (currentCategory) {
                tsResult += `    },\n`;
              }
              currentCategory = category;
            }
            if (!tsResult.includes(`'${category}': {`)) {
              tsResult += `    '${category}': {\n`;
            }
            tsResult += `      '${tokenName}': '${value}',\n`;
          } else {
            if (!tsResult.includes(`'other': {`)) {
              tsResult += `    'other': {\n`;
            }
            tsResult += `      '${tokenName}': '${value}',\n`;
          }
        });
      tsResult += `    },\n`;
      tsResult += `  },\n`;
    }
  );
  tsResult += `};\n`;

  // Write TypeScript module to file
  fs.writeFile(tsOutputFile, tsResult, 'utf8', (err) => {
    if (err) {
      console.error('Error writing TypeScript file:', err);
    } else {
      console.log('Token TypeScript module saved to', tsOutputFile);
    }
  });
  fs.writeFile(outputFile, result, 'utf8', (err) => {
    if (err) {
      console.error('Error writing file:', err);
    } else {
      console.log('Formatted tokens saved to', outputFile);
    }
  });
});
