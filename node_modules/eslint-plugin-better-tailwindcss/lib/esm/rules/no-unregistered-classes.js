import { DEFAULT_ATTRIBUTE_NAMES, DEFAULT_CALLEE_NAMES, DEFAULT_TAG_NAMES, DEFAULT_VARIABLE_NAMES } from "../options/default-options.js";
import { ATTRIBUTE_SCHEMA, CALLEE_SCHEMA, ENTRYPOINT_SCHEMA, TAG_SCHEMA, TAILWIND_CONFIG_SCHEMA, VARIABLE_SCHEMA } from "../options/descriptions.js";
import { getCustomComponentClasses } from "../tailwindcss/custom-component-classes.js";
import { getPrefix } from "../tailwindcss/prefix.js";
import { getUnregisteredClasses } from "../tailwindcss/unregistered-classes.js";
import { getCommonOptions } from "../utils/options.js";
import { createRuleListener } from "../utils/rule.js";
import { augmentMessageWithWarnings, display, escapeForRegex, getExactClassLocation, splitClasses } from "../utils/utils.js";
export const DEFAULT_IGNORED_UNREGISTERED_CLASSES = [];
const defaultOptions = {
    attributes: DEFAULT_ATTRIBUTE_NAMES,
    callees: DEFAULT_CALLEE_NAMES,
    detectComponentClasses: false,
    ignore: DEFAULT_IGNORED_UNREGISTERED_CLASSES,
    tags: DEFAULT_TAG_NAMES,
    variables: DEFAULT_VARIABLE_NAMES
};
const DOCUMENTATION_URL = "https://github.com/schoero/eslint-plugin-better-tailwindcss/blob/main/docs/rules/no-unregistered-classes.md";
export const noUnregisteredClasses = {
    name: "no-unregistered-classes",
    rule: {
        create: ctx => createRuleListener(ctx, getOptions(ctx), lintLiterals),
        meta: {
            docs: {
                description: "Disallow any css classes that are not registered in tailwindcss.",
                recommended: false,
                url: DOCUMENTATION_URL
            },
            fixable: "code",
            schema: [
                {
                    additionalProperties: false,
                    properties: {
                        ...CALLEE_SCHEMA,
                        ...ATTRIBUTE_SCHEMA,
                        ...VARIABLE_SCHEMA,
                        ...TAG_SCHEMA,
                        ...ENTRYPOINT_SCHEMA,
                        ...TAILWIND_CONFIG_SCHEMA,
                        detectComponentClasses: {
                            default: defaultOptions.detectComponentClasses,
                            description: "Whether to automatically detect custom component classes from the tailwindcss config.",
                            type: "boolean"
                        },
                        ignore: {
                            description: "A list of classes that should be ignored by the rule.",
                            items: {
                                type: "string"
                            },
                            type: "array"
                        }
                    },
                    type: "object"
                }
            ],
            type: "problem"
        }
    }
};
function lintLiterals(ctx, literals) {
    const { detectComponentClasses, ignore, tailwindConfig } = getOptions(ctx);
    const { prefix, suffix } = getPrefix({ configPath: tailwindConfig, cwd: ctx.cwd });
    const ignoredGroups = new RegExp(`^${escapeForRegex(`${prefix}${suffix}`)}group(?:\\/(\\S*))?$`);
    const ignoredPeers = new RegExp(`^${escapeForRegex(`${prefix}${suffix}`)}peer(?:\\/(\\S*))?$`);
    const customComponentClasses = detectComponentClasses
        ? getCustomComponentClasses({ configPath: tailwindConfig, cwd: ctx.cwd })
        : [];
    for (const literal of literals) {
        const classes = splitClasses(literal.content);
        const { unregisteredClasses, warnings } = getUnregisteredClasses({ classes, configPath: tailwindConfig, cwd: ctx.cwd });
        if (unregisteredClasses.length === 0) {
            continue;
        }
        for (const unregisteredClass of unregisteredClasses) {
            if (ignore.some(ignoredClass => unregisteredClass.match(ignoredClass)) ||
                customComponentClasses.includes(unregisteredClass) ||
                unregisteredClass.match(ignoredGroups) ||
                unregisteredClass.match(ignoredPeers)) {
                continue;
            }
            ctx.report({
                data: {
                    unregistered: display(unregisteredClass)
                },
                loc: getExactClassLocation(literal, unregisteredClass),
                message: augmentMessageWithWarnings("Unregistered class detected: {{ unregistered }}", DOCUMENTATION_URL, warnings)
            });
        }
    }
}
export function getOptions(ctx) {
    const options = ctx.options[0] ?? {};
    const common = getCommonOptions(ctx);
    const ignore = options.ignore ?? defaultOptions.ignore;
    const detectComponentClasses = options.detectComponentClasses ?? defaultOptions.detectComponentClasses;
    return {
        ...common,
        detectComponentClasses,
        ignore
    };
}
//# sourceMappingURL=no-unregistered-classes.js.map